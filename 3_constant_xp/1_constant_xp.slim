// sweep_recap_with_restart.slim - SLiM 4

initialize() {
    initializeSLiMOptions(keepPedigrees=T);
    initializeTreeSeq();

    defineConstant("d_sel", 0.1);
    defineConstant("d_mloc", 5000000);
    defineConstant("d_chr", 10000000);
    defineConstant("d_rr", 1e-8);
    defineConstant("d_hapsel", 1);
    defineConstant("outputPathPrefix", "../output/3_1_constant_xp/"); // ending slash important
    defineConstant("sampleTimes", c(100, 200, 300, 400, 500, 1000, 2000));
    defineConstant("d_ne", 10000);
    defineConstant("DRIFT_GEN", 0);
    defineConstant("MAX_GEN", 5000);
    defineConstant("MUT_GEN", 1500);
    defineConstant("SURVIVAL_CHECK_GEN", MUT_GEN + DRIFT_GEN);
    defineConstant("SPLIT_GEN", 500);
    defineConstant("SPLIT_NEUTRAL_POP_SIZE", 10000); // Generation to split population into two (after burn-in and sweep introduction)
    defineConstant("SPLIT_SWEEP_POP_SIZE", 10000); // Generation to split population into two (after burn-in and sweep introduction)


    initializeMutationRate(0);
    initializeMutationType("m2", 0.5, "f", d_sel);
    m2.convertToSubstitution = F;
    m2.mutationStackPolicy = "l";
    initializeGenomicElementType("g1", m2, 1.0);
    initializeGenomicElement(g1, 0, d_chr - 1);
    initializeRecombinationRate(d_rr);
}

1 early() {
    sim.addSubpop("p1", d_ne);
    defineConstant("simID", getSeed());

    sim.setValue("attempt", 0);
    sim.setValue("mutationSurvived", F);
    sim.setValue("hasFixed", F);
}

SPLIT_GEN early() {
    sim.addSubpopSplit("p2", SPLIT_NEUTRAL_POP_SIZE, p1); //sample d_ne / 2 individuals from p1 into the new p2
    p1.setSubpopulationSize(SPLIT_SWEEP_POP_SIZE); // reduce p1 size to maintain total population size
    catn("Split complete.");
}

// 100 early() { sim.addSubpopSplit("p2", 100, p1); }
// 100:150 early() {
// migrationProgress = (sim.cycle - 100) / 50;
// p1.setMigrationRates(p2, 0.2 * migrationProgress);
// p2.setMigrationRates(p1, 0.8 * migrationProgress);
// }
// 1000 early() { sim.addSubpopSplit("p3", 10, p2); }
// 1000:1100 early() {
// p3Progress = (sim.cycle - 1000) / 100;
// p3.setSubpopulationSize(asInteger(990 * p3Progress + 10));
// p1.setMigrationRates(p3, 0.1 * p3Progress);
// p2.setMigrationRates(p3, 0.01 * p3Progress);
// }
// 2000 early() { p2.setSubpopulationSize(0); }


501 early() {
    catn("After regulation: p1 = " + p1.individualCount + ", p2 = " + p2.individualCount);
}

function (void) introduceSweep(void) {
    sim.setValue("attempt", sim.getValue("attempt") + 1);
    sim.setValue("mutationSurvived", F);
    sim.setValue("hasFixed", F);

    targetGenomes = sample(p1.genomes, d_hapsel);
    for (g in targetGenomes) {
        g.addNewDrawnMutation(m2, d_mloc);
    }
    muts = sim.mutationsOfType(m2);
    if (size(muts) == 1) {
        sim.setValue("beneficialMutId", muts[0].id);
        cat("Attempt #" + sim.getValue("attempt") +
            ": Introduced sweep mutation at gen " + community.tick + "\n");
    } else {
        cat("Unexpected number of mutations after introduction: " + size(muts) + "\n");
    }
}

function (void) reloadSim(void){
    sim.readFromPopulationFile(outputPathPrefix + "/slim_" + simID + ".txt");
    setSeed(rdunif(1, 0, asInteger(2^62) - 1));
}


MUT_GEN late() {
    sim.setValue("attempt", 0);
    sim.setValue("mutationSurvived", F);
    sim.setValue("hasFixed", F);

    catn("Output path prefix: " + outputPathPrefix);
    sim.outputFull(outputPathPrefix+"/slim_" + simID + ".txt"); // save the state of the simulation
    cat("Loaded last slim simulation; current generation = " + community.tick + " at attempt " + sim.getValue("attempt")+ "\n");
    introduceSweep();  
}


// Check if mutation survived early drift (by gen 10050)
SURVIVAL_CHECK_GEN late() {
    muts = sim.mutationsOfType(m2);
    afs = sim.mutationFrequencies(p1, muts);

    if (size(muts) != 1) {
        cat("Sweep lost before gen " + SURVIVAL_CHECK_GEN + " â†’ restarting\n");
        
        reloadSim();
        introduceSweep();
    } else {
        sim.setValue("mutationSurvived", T);
        cat("Sweep survived drift (AF = " + afs[0] + ") â†’ continuing\n");
    }
}

// Track allele frequency, sample, detect fixation
late() {
    muts = sim.mutationsOfType(m2);
    afs = sim.mutationFrequencies(p1, muts);

    if(size(afs) == 1){
        af = afs[0];
    }else{
        af = 0.0; // If mutation not found, set AF to 0
    }

    if(community.tick >= MUT_GEN)
        cat("Gen " + community.tick + ": AF = " + af + "\n");

    if(af==0.0 & community.tick > MUT_GEN + DRIFT_GEN){
        reloadSim();
        introduceSweep(); //re-introduce sweep if lost
    }

    if (any(sampleTimes + MUT_GEN == community.tick)) {
        prefix = outputPathPrefix + "gen" + (community.tick-MUT_GEN);
        cat("prefix: "+ prefix + "\n");
        sim.treeSeqOutput(prefix + ".trees");

        phase = p1.individualCount;

        f = prefix + "_freq.txt";
        line2 =  paste(community.tick-MUT_GEN, sim.getValue("attempt"), af, phase, sep='\t');
				writeFile(f, line2, append=F);
	

        cat(" â†³ wrote " + prefix + ".trees and _freq.txt\n");
    }

    if (af == 1.0 & !sim.getValue("hasFixed")) {
        sim.setValue("hasFixed", T);
        cat("Sweep fixed at gen " + community.tick + "\n");

        prefix = outputPathPrefix + "gen" + community.tick + "_fixed";
        sim.treeSeqOutput(prefix + ".trees");
    }

    if (af >= 0.74 & af <= 0.76) {
        cat("Sweep reached 75% at gen " + community.tick + "\n");
        prefix = outputPathPrefix + "gen" + community.tick + "_final";
        sim.treeSeqOutput(prefix + ".trees");

        f = prefix + "_freq.txt";
        phase = 0;
        line2 =  paste(community.tick-MUT_GEN, sim.getValue("attempt"), af, phase, sep='\t');
				writeFile(f, line2, append=F);
    }

    if (community.tick == MAX_GEN) {
        cat("Finished at gen " + community.tick + "\n");
        sim.simulationFinished();
    }
}


// Dummy callback at final generation to keep SLiM alive
MAX_GEN late() {
    // Nothing here â€” this ensures SLiM keeps running until gen 11000
}
